# -*- coding: utf-8 -*-

"""
Navigation Plotter
-----------------
DESCRIPTION



Created by J.G.Aguado
DATE
"""

import datetime
import math
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg

from PyQt5 import QtCore, QtWidgets,QtGui

from PyQt5.QtWidgets import (QApplication, QMainWindow, QFileDialog)
from matplotlib.backends.backend_qt4agg import NavigationToolbar2QT as \
    NavigationToolbar
from gui_py import Ui_Naviation_plotter
from reportlab.lib import colors
from reportlab.lib.pagesizes import A4, portrait
from reportlab.platypus import SimpleDocTemplate, Image, Table, TableStyle, \
    Paragraph
from reportlab.lib.styles import getSampleStyleSheet
from PIL import Image as p_image


class NavigationPlotter(QMainWindow, Ui_Naviation_plotter):

    def __init__(self, parent=None):
        super(NavigationPlotter, self).__init__(parent)

        # Autogenerated code from designer
        self.setupUi(self)

        # Initialize variables
        self.vars_initialization()

        # Add area for plotting
        self.plot()

        # Generate interface connections
        self.connections()

    def __call__(self, event):
        print('click', event)
        if event.inaxes != self.line.axes: return

        if self.start_stop_pb.text() == 'Stop':
            if event.dblclick:
                self.start_stop_pb.setText("Start")

            self.xs.append(event.xdata)
            self.ys.append(event.ydata)
            self.line.set_data(self.xs, self.ys)
            self.line.set_color(self.lines_color_cb.currentText())
            self.line.figure.canvas.draw()
            self.add_checkpoint()
            if len(self.xs) > 1:
                if self.info_box_chb.isChecked():
                    x = [self.xs[-1], self.xs[-2]]
                    y = [self.ys[-1], self.ys[-2]]
                    self.show_info(x, y, self.heading[:-2], self.distance,
                                   self.time, self.heading_r[-1])

                if self.line_marker_chb.isChecked():
                    distance = float(self.distance)
                    self.show_line_mark(self.xs[-2], self.ys[-2],
                                        self.heading_r[-1], distance)


        elif self.cal_scale:
            self.xs.append(event.xdata)
            self.ys.append(event.ydata)
            self.line.set_data(self.xs, self.ys)
            self.line.figure.canvas.draw()
            self.line.set_color('red')

            self.point.set_color('red')
            self.point.set_data(self.xs, self.ys)
            self.point.set_marker('o')
            if len(self.xs) == 2:
                self.calibrate_scale()

        elif self.cal_north:
            self.xs.append(event.xdata)
            self.ys.append(event.ydata)
            self.line.set_data(self.xs, self.ys)
            self.line.figure.canvas.draw()
            self.line.set_color('blue')


            print(self.xs, self.ys)
            if len(self.xs) == 2:
                self.arrow()
                self.calibrate_north()

    def vars_initialization(self):
        # Config params
        self.cal_scale = False
        self.scale = 0
        self.cal_north = False
        self.north_d = 0
        self.speed = 0
        self.fuel_consumption = 0

        self.map_path = None
        self.l_x = [0, 480]
        self.l_y = [0, 720]
        self.dpi = 0
        # Display GUI info
        d = 'Nm'
        f = 'Gal/h'
        self.scale_units_cb.addItems((d, 'Km', 'm'))
        self.speed_units_cb.addItems(('Kt', 'Km/h'))
        self.fuel_units_cb.addItems((f, 'L/h'))
        self.checkpoints_tb.setHorizontalHeaderLabels(('Checkpoint',
                                                       'Distance (%s)' % d,
                                                       'Total distance (%s)' % d,
                                                       'Time',
                                                       'Total time',
                                                       'Fuel (%s)' % f,
                                                       'Total Fuel (%s)' % f,
                                                       'Heading (º)'))
        self.checkpoints_tb.setColumnWidth(0, 100)
        self.checkpoints_tb.setColumnWidth(1, 100)
        self.checkpoints_tb.setColumnWidth(2, 120)
        self.checkpoints_tb.setColumnWidth(3, 100)
        self.checkpoints_tb.setColumnWidth(4, 100)
        self.checkpoints_tb.setColumnWidth(5, 100)
        self.checkpoints_tb.setColumnWidth(6, 100)
        self.checkpoints_tb.setColumnWidth(7, 100)

        self.lines_color_cb.addItems(('green', 'royalblue', 'orange', 'violet'))

        # Checkpoints
        self.distance = 0
        self.total_distance = 0
        self.time = 0
        self.total_time = 0
        self.heading = 0
        self.total_fuel = 0
        self.heading_r = []

    def plot(self):
        self.fig = plt.figure(num=None, figsize=(10, 15), dpi=80,
                              facecolor='w',
                             edgecolor='k')
        self.ax = self.fig.add_subplot(111)

        self.line, = self.ax.plot([0], [0])  # empty line
        self.point,  = self.ax.plot([0], [0])

        self.xs = []
        self.ys = []
        self.cid = self.line.figure.canvas.mpl_connect('button_press_event',
                                                       self)
        self.add_figure_canvas_and_toolbar_to_widget(self.print_ly, self.fig)

        self.set_view()

    def add_figure_canvas_and_toolbar_to_widget(self, widget, figure):
        if widget.count() > 0:
            for i in reversed(range(widget.count())):
                w = widget.itemAt(i)
                w.widget().deleteLater()
                w.widget().setParent(None)

        canvas = figure.canvas
        toolbar = NavigationToolbar(canvas, self)

        widget.addWidget(toolbar)
        widget.addWidget(canvas)

        return figure

    def connections(self):
        self.import_pb.clicked.connect(self.open_map)
        self.view_pb.clicked.connect(self.edit_view)
        self.start_stop_pb.clicked.connect(self.start_stop)
        self.reset_pb.clicked.connect(self.reset)
        self.scale_pb.clicked.connect(self.set_scale)
        self.north_pb.clicked.connect(self.set_north)
        self.speed_sb.valueChanged.connect(self.set_speed)
        self.speed_units_cb.currentIndexChanged.connect(self.set_speed)
        self.fuel_sb.valueChanged.connect(self.set_fuel_consumption)
        self.fuel_units_cb.currentIndexChanged.connect(self.set_fuel_consumption)
        self.save_config_pb.clicked.connect(self.reset)
        self.info_box_chb.clicked.connect(self.cb_display_changed)
        self.line_marker_chb.clicked.connect(self.cb_display_changed)
        self.save_pb.clicked.connect(self.save_as_pdf)

    def update_table_header(self):
        d = self.scale_units_cb.currentText()
        if self.fuel_units_cb.currentText() == 'Gal/h':
            f = 'Gal'
        else:
            f = 'L'

        self.checkpoints_tb.setHorizontalHeaderLabels(('Checkpoint',
                                                       'Distance (%s)' % d,
                                                       'Total distance (%s)' % d,
                                                       'Time',
                                                       'Total time',
                                                       'Fuel (%s)' % f,
                                                       'Total Fuel (%s)' % f,
                                                       'Heading (�)'))

    def open_map(self):
        map_path = self.load_map()
        if self.map_path != map_path:
            self.map_path = map_path
            self.plot_map(new=True)
        self.set_view()

    def load_map(self):
        ext = "PNG (*.png);;JPEG (*.jpg)"
        options = QFileDialog.Options()
        path = None
        path, _ = QFileDialog.getOpenFileName(
            self,
            "Select map file", ".\\img\\", ext,
            options=options)
        if path:
            return path

    def plot_map(self, new=False):
        img = np.flipud(plt.imread(self.map_path))
        self.dpi = max(p_image.open(self.map_path).info['dpi'])
        if new:
            self.l_x = [0, img.shape[1]]
            self.l_y = [0, img.shape[0]]

        self.ax.imshow(img, origin='lower')
        plt.draw()
        self.set_view()

    def set_view(self):
        plt.axis((self.l_x[0], self.l_x[1], self.l_y[0], self.l_y[1]))
        plt.axis('off')
        plt.draw()

    def edit_view(self):
        self.l_x = self.ax.get_xlim()
        self.l_y = self.ax.get_ylim()

    def start_stop(self):
        self.update_table_header()

        if self.start_stop_pb.text() == 'Start':
            self.start_stop_pb.setText('Stop')
        else:
            self.start_stop_pb.setText('Start')

    def reset(self):

        self.xs = []
        self.ys = []
        self.line.set_data(self.xs, self.ys)
        self.point.set_data(self.xs, self.ys)

        self.line.figure.canvas.draw()
        self.start_stop_pb.setText('Start')
        self.ax.cla()

        self.line, = self.ax.plot([0], [0])  # empty line
        self.point, = self.ax.plot([0], [0])
        self.plot_map()

        for i in range(self.checkpoints_tb.rowCount()):
            self.checkpoints_tb.removeRow(0)

    def set_scale(self):

        self.cal_scale = True

    def set_north(self):
        self.cal_north = True

    def calibrate_scale(self):
        # Distances in SI (m)

        real_distance = self.scale_sb.value()
        if self.scale_units_cb.currentText() == 'Nm':
            real_distance *= 1852
        elif self.scale_units_cb.currentText() == 'Km':
            real_distance *= 1000

        measured_distance = np.sqrt((self.xs[1]-self.xs[0])**2 +
                                    (self.ys[1]-self.ys[0])**2)

        self.scale = real_distance/measured_distance

        self.xs = []
        self.ys = []
        self.cal_scale = False

    def calibrate_north(self):
        self.north_r = np.pi/2 - math.atan2((self.ys[1]-self.ys[0]),
                                            (self.xs[1]-self.xs[0]))


        self.north_d = np.degrees(self.north_r)

        print(self.north_d)
        self.xs = []
        self.ys = []
        self.cal_north = False

    def set_speed(self):
        # Speed in SI (m/s)

        self.speed = self.speed_sb.value()
        if self.speed_units_cb.currentText() == 'Kt':
            self.speed *= 0.514444
        elif self.scale_units_cb.currentText() == 'Km/h':
            self.speed *= 0.277778

    def set_fuel_consumption(self):
        # Fuel in Gal/h

        self.fuel_consumption = self.fuel_sb.value()
        if self.fuel_units_cb.currentText() == 'L/h':
            self.fuel_consumption /= 3.78541

    def arrow(self, angle=30, size=0.1):
        beta = np.radians(angle)
        d = size * np.sqrt((self.xs[1]-self.xs[0])**2 +
                           (self.ys[1]-self.ys[0])**2)

        alpha = math.atan2((self.ys[1]-self.ys[0]),(self.xs[1]-self.xs[0]))

        gamma_1 = 180 + alpha - beta
        gamma_2 = -180 + alpha + beta

        self.xs.append(self.xs[1]+d*np.cos(gamma_1))
        self.ys.append(self.ys[1]+d*np.sin(gamma_1))
        self.xs.append(self.xs[1])
        self.ys.append(self.ys[1])
        self.xs.append(self.xs[1]+d*np.cos(gamma_2))
        self.ys.append(self.ys[1]+d*np.sin(gamma_2))
        self.line.set_data(self.xs, self.ys)
        self.line.figure.canvas.draw()

    def add_checkpoint(self):
        if len(self.xs) > 1:
            distance = self.scale * np.sqrt((self.xs[-1]-self.xs[-2])**2 +
                                                 (self.ys[-1]-self.ys[-2])**2)

            time = round(distance / self.speed, 4)

            if self.scale_units_cb.currentText() == 'Nm':
                distance /= 1852
            elif self.scale_units_cb.currentText() == 'Km':
                distance /= 1000

            self.total_distance += round(distance,2)
            self.total_time += time

            fuel = (time/3600) * self.fuel_consumption
            if self.fuel_units_cb.currentText() == 'L/h':
                fuel /= 3.78541
            fuel = round(fuel, 2)
            self.total_fuel += fuel

            self.heading_r.append(math.atan2(
                (self.ys[-1]-self.ys[-2]),
                (self.xs[-1]-self.xs[-2])))

            heading = -self.north_d + 90 - np.degrees(self.heading_r[-1])

            if heading < 0:
                heading = 360 + heading


        else:
            ID = 0
            distance = 0
            self.total_distance = 0
            time = 0
            self.total_time = 0
            fuel = 0
            self.total_fuel = 0
            heading = 0

        self.distance = str(round(distance,2))
        self.time = str(datetime.timedelta(seconds=round(time,2),
                                           microseconds=0))[:-7]

        show_total_time = str(datetime.timedelta(seconds=self.total_time,
                                                 microseconds=0))[:-7]
        self.heading = str(round(heading,0))

        rowPosition = self.checkpoints_tb.rowCount()
        self.checkpoints_tb.insertRow(rowPosition)
        self.checkpoints_tb.setItem(rowPosition, 0,
                                    QtWidgets.QTableWidgetItem("Enter checkpoint "
                                                               "name"))
        self.checkpoints_tb.setItem(rowPosition, 1,
                                    QtWidgets.QTableWidgetItem(self.distance))
        self.checkpoints_tb.setItem(rowPosition, 2,
                                    QtWidgets.QTableWidgetItem(str(self.total_distance)))
        self.checkpoints_tb.setItem(rowPosition, 3,
                                    QtWidgets.QTableWidgetItem(self.time))
        self.checkpoints_tb.setItem(rowPosition, 4,
                                    QtWidgets.QTableWidgetItem(show_total_time))
        self.checkpoints_tb.setItem(rowPosition, 5,
                                    QtWidgets.QTableWidgetItem(str(fuel)))
        self.checkpoints_tb.setItem(rowPosition, 6,
                                    QtWidgets.QTableWidgetItem(str(self.total_fuel)))
        self.checkpoints_tb.setItem(rowPosition, 7,
                                QtWidgets.QTableWidgetItem(self.heading[:-2]))

    def cb_display_changed(self):
        self.ax.cla()

        self.line, = self.ax.plot([0], [0])  # empty line
        self.point, = self.ax.plot([0], [0])
        self.line.set_data(self.xs, self.ys)
        self.line.set_color(self.lines_color_cb.currentText())
        self.line.figure.canvas.draw()
        self.plot_map()

        for ii in range(self.checkpoints_tb.rowCount() - 1):
            if self.info_box_chb.isChecked():
                x = [self.xs[ii], self.xs[ii + 1]]
                y = [self.ys[ii], self.ys[ii + 1]]
                distance = self.checkpoints_tb.item(ii + 1, 1).text()
                time = self.checkpoints_tb.item(ii + 1, 3).text()
                heading = self.checkpoints_tb.item(ii + 1, 7).text()
                dir = self.heading_r[ii]
                self.show_info(x, y, heading, distance, time, dir)

            if self.line_marker_chb.isChecked():
                x = self.xs[ii]
                y = self.ys[ii]
                heading = self.heading_r[ii]
                distance = float(self.checkpoints_tb.item(ii + 1, 1).text())

                self.show_line_mark(x, y, heading, distance)

    def show_info(self, x, y, heading, distance, time, dir):
        offset = (self.ax.get_xlim()[1] - self.ax.get_xlim()[0]) / 15
        x_m = offset * np.cos(dir + np.pi / 2) + \
              (x[0] + x[1]) / 2
        y_m = offset * np.sin(dir + np.pi / 2) + \
              (y[0] + y[1]) / 2
        text = heading + 'º\n' + \
               distance + self.scale_units_cb.currentText() + \
               '\n' + time[2:7] + ' min'
        self.ax.text(x_m, y_m, text, size=self.text_size_sb.value(),
                     rotation=0.,
                     ha="center", va="center",
                     bbox=dict(boxstyle="round",
                               facecolor=self.lines_color_cb.currentText(),
                               alpha=0.8
                               )
                     )
        plt.draw()

    def show_line_mark(self, x, y, heading, distance, d=None):
        l_x = self.ax.get_xlim()
        l_y = self.ax.get_ylim()
        if d is None:            
            d = (self.l_x[1] - self.l_x[0]) / 30

        line_dist = self.speed * 60 * self.mins_sb.value()


        if self.scale_units_cb.currentText() == 'Nm':
            distance *= 1852
        elif self.scale_units_cb.currentText() == 'Km':
            distance *= 1000

        n_lines = math.floor(distance/line_dist)
        line_dist /= self.scale

        for ii in range(1, n_lines+1):
            xp = x + line_dist*ii*np.cos(heading)
            yp = y + line_dist*ii*np.sin(heading)

            x1 = d/2 * np.cos(heading + np.pi/2) + xp
            x2 = d/2 * np.cos(heading - np.pi/2) + xp
            y1 = d/2 * np.sin(heading + np.pi/2) + yp
            y2 = d/2 * np.sin(heading - np.pi/2) + yp

            self.ax.plot([x1,x2], [y1, y2],
                           color=self.lines_color_cb.currentText())
            plt.draw()
            self.ax.set_xlim(l_x[0], l_x[1])
            self.ax.set_ylim(l_y[0], l_y[1])

    def save_as_pdf(self):
        options = QFileDialog.Options()
        path, _ = QFileDialog.getSaveFileName(
            self, options=options)

        doc = SimpleDocTemplate(path+ '.pdf', pagesize=A4,
                                rightMargin=30, leftMargin=30, topMargin=30,
                                bottomMargin=18)
        doc.pagesize = portrait(A4)
        elements = []
        data = []
        for i in range(self.checkpoints_tb.rowCount()):
            line = []
            for j in range(self.checkpoints_tb.columnCount()):
                if i < 1:
                    line.append(
                        self.checkpoints_tb.horizontalHeaderItem(j).text())
                else:
                    line.append(self.checkpoints_tb.item(i, j).text())
            data.append(line)


        im_path = 'im_aux.png'
        self.save_plot(im_path)

        style = TableStyle([('ALIGN', (1, 1), (-2, -2), 'RIGHT'),
                            ('TEXTCOLOR', (1, 1), (-2, -2), colors.red),
                            ('VALIGN', (0, 0), (0, -1), 'BOTTOM'),
                            ('TEXTCOLOR', (0, 0), (0, -1), colors.blue),
                            ('ALIGN', (0, -1), (-1, -1), 'CENTER'),
                            ('VALIGN', (0, -1), (-1, -1), 'MIDDLE'),
                            ('TEXTCOLOR', (0, -1), (-1, -1), colors.green),
                            (
                            'INNERGRID', (0, 0), (-1, -1), 0.25, colors.black),
                            ('BOX', (0, 0), (-1, -1), 0.25, colors.black),
                            ])

        # Configure style and word wrap
        s = getSampleStyleSheet()
        s = s["BodyText"]
        s.wordWrap = 'CJK'
        data2 = [[Paragraph(cell, s) for cell in row] for row in data]
        t = Table(data2)
        t.setStyle(style)

        I = Image(im_path)
        proportion = 0.9
        I.drawWidth = doc.width * proportion
        ratio = (self.l_y[1]-self.l_y[0])/(self.l_x[1]-self.l_x[0])
        I.drawHeight = doc.width * ratio * proportion
        # Send the data and build the file
        elements.append(I)
        elements.append(t)
        doc.build(elements)

    def save_plot(self, path):
        dpi = self.dpi+250
        plt.savefig(path, dpi=dpi, bbox_inches='tight', pad_inches=0)


if __name__ == '__main__':
    import sys
    def my_excepthook(type, value, tback):
        """
        Hook to make QT not break on exceptions and show info
        """
        # then call the default handler
        sys.__excepthook__(type, value, tback)

    sys.excepthook = my_excepthook

    app = QApplication(sys.argv)
    window = NavigationPlotter(parent=None)
    window.show()
    sys.exit(app.exec_())